package br.com.caelum.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

import javax.sql.DataSource;

import org.hsqldb.jdbc.JDBCPool;

public class ConnectionPool {

	private DataSource dataSource;

	ConnectionPool() {
		JDBCPool pool = new JDBCPool();
		pool.setUrl("jdbc:hsqldb:hsql://localhost/loja-virtual");
		pool.setUser("SA");
		pool.setPassword("");

		this.dataSource = pool;
	}

	public Connection getConnection() throws SQLException {
		Connection connection = dataSource.getConnection();
		System.out.println("Conexão aberta com pool!");
		return connection;
	}

	public Connection getConnectionSemPool() throws SQLException {
		Connection connection = DriverManager.getConnection("jdbc:hsqldb:hsql://localhost/loja-virtual", "SA", "");
		System.out.println("Conexão aberta sem pool!");
		return connection;
	}

}

/**
 * 
 * 
 * O connection POOL e importante para utilizar as conecxoes entre diversos
 * clientes
 * 
 * 
 * Repare que utilizamos a interface DataSource pois ela só disponibiliza os
 * getters, não os setters. Não desejamos alterar os setters após a construção
 * de nosso pool, portanto usamos a interface. Tiraremos também a característica
 * static de nosso método: é importante criar um Database (e consequentemente o
 * pool) antes de invocar o método.
 * 
 * 
 * Alguns servidores na cloud pedem para não usarmos connection pool pois eles
 * mesmos já trazem seu connection pool ou lidam com tais situações. Os
 * servidores Java EE também já fornecem um connection pool de maneira
 * declarativa (configurando em algum arquivo externo a aplicação) e basta
 * recebermos o DataSource dentro de nossa aplicação.
 * 
 * 
 * Em um cenário onde diversos clientes podem acessar uma mesma aplicação
 * simultaneamente: A prática do pool de conexões consiste em deixar um número
 * fixo ou dinâmico de conexões abertas e reciclá-las utilizando em novas
 * requisições.
 * 
 *
 * 
 * 
 * Em um pool simples com 9 conexões, o que acontece quando o 10º usuário se
 * conecta e todas estão ocupadas? O que acontece quando, posteriormente, o
 * terceiro usuário termina sua tarefa?
 * 
 * Que variações você sugeriria fazer na implementação de um pool de conexões
 * para evitar que um usuário espere muito tempo? E o que fazer para evitar que
 * em horários de pico o servidor não fique com poucas conexões para um número
 * grande de usuários?
 * 
 * 
 * 
 * \ Opinião do instrutor
 * 
 * 
 * No cenário descrito, o 10º usuário esperará. Quando o terceiro usuário
 * terminar sua tarefa, o décimo usuário passará a usar a conexão liberada.
 * 
 * Uma sugestão seria utilizar um número variável de conexões: delimitamos um
 * número mínimo e máximo e deixamos que o servidor se adapte com o número de
 * conexões de acordo com a necessidade atual. Por exemplo podemos configurar 10
 * e 100. A medida que novas conexões vão sendo necessárias, o servidor cria,
 * até chegar a 100. Quando elas não são necessárias, ele deixa diminuir o
 * número de conexões ativas até um mínimo de 10.
 * 
 * 
 */
