
* Certificação JAVA *

/*****************************************/

//$~/Documents/Carloss/Desenvolvimento/estudos-java/src:
//javac br/com/certificacao/aula06/Exercicio7.java
//java -classpath . br.com.certificacao.aula06.Exercicio7

/******************************************/

* Padrão de Interface Simples
Interface methods are implicitly public, abstract (except for static and default methods), so above given interface is implicitly public. 
When we override methods, we have to use less restrictive or same level access modifier for overriding method. 

--//--
public interface A{
    void print();
}
-- Override interface method A:
public void print(){ System.out.println("A implemented"); }
--//--

interface A {
	//somente constantes ou assinatura de métodos.
    public static final int TAMANHO_SENHA = 8; //constante
    public abstract void autentica(String login, String senha); //assinatura do método
}

-----------------//-----------------------

• Interfaces Funcionais
https://www.ibm.com/developerworks/br/library/j-java8idioms7/index.html

Predicate Interface: 
----------import java.util.function.*;----------ou
----------import java.util.function.Predicate----------
----------import java.util.function.Consumer----------

//Lambda - Lambda Sintaxe básica: ( parameters ) -> { code }
* filter usa Predicate<T> e forEach usa Consumer<T>. *
List<String> lista =Arrays.asList("a", "b", "c", "d");//asList traz um array com tamanho fixo só pode alterar os valores.
for (String l : lista) {
    System.out.println(l);
}
lista.forEach(l -> System.out.println(l));

//interface funcional
-Uma interface funcional tem apenas um método abstrato.
-Um método abstrato que também for um método público na classe Object não será contado como esse método.
-Uma interface funcional pode ter métodos "default" e métodos estáticos.
-para conferir se é interface funcional basta usar a annotation @FunctionalInterface -> se não for funcional, o código não compila.




/******************************************/

Throws X TryCatch.
Throws seu metodo declara que pode lançar o erro e se este ocorrer o metodo que o chamou deve tratar ou declarar novamente ate chegar ao inicio da pilha. 
Try catch - o erro se ocorrer sera capturado pelo bloco catch correspondente e tratará a excessão de acordo com a sua implementação para este bloco e a excessão não será lançada ao metodo chamador

/******************************************/

When overloading method we must change the argument list, also we can change the return type.

interface A{
	default boolean equals(Object obj){}
}
You cannot use default methods to override any of the non-final methods in the java.lang.Object class.
For example, you cannot override the equals method, it will cause a compile time error.
So in above code, trying to override equals method at line 5, causes a compile time error. 


/***************************************/

Instanciar Classes Anônimas.

JButton botaoSair = new JButton("Sair");
ActionListener sairListener = new ActionListener() {
	public void actionPerformed(ActionEvent e) {
		System.exit(0);
	}
};
botaoSair.addActionListener(sairListener);

-----------ou

JButton botaoSair = new JButton("Sair");
botaoSair.addActionListener( new ActionListener() {
	public void actionPerformed(ActionEvent e) {
		System.exit(0);
	}
});

/***************************************/

Legal JAVA Access Modifiers:
Abstract, Final, Native;
Private, Protected, Public;
Static, Synchronized, Transient;
Volatile, StrictFP;

/***************************************/

//Convertendo String para primitivos: int i = Integer.parseInt("140");
//Convertendo String diretamente para um wrapper: Long j = Long.valueOf("235555");
//Convertendo de wrappers para primitivos: double j = (new Long("123")).doubleValue();

//Convertendo String para Wrapper e Wrapper para primitivo diretamente: double h = Double.valueOf("27").floatValue();

/***************************************/

Variáveis ou métodos protegidas não serão acessadas por subclasses dos parentes em pacotes diferentes.

/***************************************/

Um contrutor não pode ter um retorno, nem mesmo void.
Um contrutor não pode ser final, static ou abstract

/***************************************/

An object is eligible for GC when there is no live thread can reach it.
Object Class has a finalize() method.


/***************************************/

para lancar uma IOException basta throw new FileNotFoundException();



/***************************************/

Valores baixos é possível que o resultado seja true, mesmo usando 2 objetos diferentes.
Todos Boolean e Byte ;
Short e Integer de -128 até 127;
Caracter ASCII, como letras, números etc.

Integer i1 = 123;
Integer i2 = 123;
System.out.println(i1 == i2); //true
System.out.println(i1.equals(i2)); //true

---------------------//-----------------------

Integer i1 = 1234;
Integer i2 = 1234;
System.out.println(i1 == i2); //false
System.out.println(i1.equals(i2)); //true


/***************************************/

Switch:
The variable used in a switch statement can only be integers, convertable integers (byte, short, char), strings and enums.
The value for a case must be the same data type as the variable in the switch and it must be a constant or a literal.

/***************************************/

		Collection col = new ArrayList(Arrays.asList(sts));
		
/***************************************/